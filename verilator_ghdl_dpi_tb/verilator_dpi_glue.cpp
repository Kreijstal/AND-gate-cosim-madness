#include <cstdio> // For printf

// Verilator Headers
#include "verilated.h"
#include "Vand_gate.h" // Generated by Verilator for our DUT

// DPI Header
#include "svdpi.h" // Standard DPI header

// Global Verilator objects
static VerilatedContext* contextp = nullptr;
static Vand_gate* verilator_dut = nullptr;

// Helper function (optional)
static inline bool svLogicToBool(svLogic val) {
    return (val == sv_1);
}

static inline svLogic boolToSvLogic(bool val) {
    return val ? sv_1 : sv_0;
}


// DPI Export Functions (Implementation)
// Must be extern "C" to prevent C++ name mangling
extern "C" {

    // Initialize the Verilator simulation model
    void dpi_init() {
        if (!contextp) {
            contextp = new VerilatedContext;
            // Verilated::traceEverOn(true); // Optional: Enable VCD tracing if needed
            printf("DPI C++: Initializing Verilator context.\n");
        }
        if (!verilator_dut) {
            verilator_dut = new Vand_gate{contextp, "DUT"}; // Pass context
            printf("DPI C++: Instantiated Verilator model (Vand_gate).\n");
        }
        // Initial evaluation? Sometimes needed.
        // verilator_dut->eval();
        fflush(stdout);
    }

    // Set inputs on the Verilator model
    void dpi_set_inputs(const svLogic a_in, const svLogic b_in) {
        if (!verilator_dut) {
            printf("DPI C++ ERROR: dpi_set_inputs called before dpi_init!\n");
            fflush(stdout);
            return; // Or handle error appropriately
        }
        verilator_dut->a = svLogicToBool(a_in);
        verilator_dut->b = svLogicToBool(b_in);
        // printf("DPI C++: Set inputs a=%d, b=%d\n", verilator_dut->a, verilator_dut->b);
        // fflush(stdout);
    }

    // Trigger one evaluation cycle of the Verilator model
    void dpi_eval() {
        if (!verilator_dut) {
            printf("DPI C++ ERROR: dpi_eval called before dpi_init!\n");
            fflush(stdout);
            return; // Or handle error appropriately
        }
        verilator_dut->eval();
        // printf("DPI C++: Evaluated model.\n");
        // fflush(stdout);
    }

    // Get the output 'y' from the Verilator model
    svLogic dpi_get_output() {
        if (!verilator_dut) {
            printf("DPI C++ ERROR: dpi_get_output called before dpi_init!\n");
            fflush(stdout);
            return sv_x; // Return 'X' on error
        }
        svLogic result = boolToSvLogic(verilator_dut->y);
        // printf("DPI C++: Got output y=%d -> svLogic=%d\n", verilator_dut->y, result);
        // fflush(stdout);
        return result;
    }

    // Finalize/cleanup the Verilator model
    void dpi_final() {
        if (verilator_dut) {
            verilator_dut->final(); // Call Verilator's final cleanup
            delete verilator_dut;
            verilator_dut = nullptr;
            printf("DPI C++: Finalized and deleted Verilator model.\n");
        }
        if (contextp) {
            delete contextp;
            contextp = nullptr;
            printf("DPI C++: Deleted Verilator context.\n");
        }
        fflush(stdout);
    }

} // extern "C"


// Provide dummy sc_time_stamp() for Verilator libraries that might need it.
// This is sometimes required even if SystemC is not directly used.
// Define it unconditionally.
double sc_time_stamp() {
    // Return a constant time value, as simulation time is managed by GHDL
    // If time synchronization is needed, this would require more complex VPI/VHPI calls
    // or using VerilatedContext::time() if driven externally.
    // For simple DPI calls triggered by GHDL, 0.0 is usually sufficient.
    return 0.0;
}